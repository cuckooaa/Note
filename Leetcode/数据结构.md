## 零、常用枚举技巧

### note（枚举右，维护左）
对于双变量问题，例如两数之和ai​+aj​=t，可以**枚举右边的aj​，转换成单变量问题**，也就是**在aj​左边查找是否有ai​=t−aj**，这可以**用哈希表维护**。

### note（枚举中间）
三变量i, j, k 枚举中间的 nums[j]                         
定义 **suf[k]（可以为list,map,set...）表示从 nums[k] 到 nums[size−1] 的值（后缀）**，              
定义 **pre[i]（可以为list,map,set...）表示从 nums[0] 到 nums[i] 的值（前缀）**                      
前缀可以和答案一起算。

[2909. 元素和最小的山形三元组 II 1479](https://leetcode.cn/problems/minimum-sum-of-mountain-triplets-ii/)*（未完成）*

### note（遍历对角线）
*对于每条对角线，行号 i 减列号 j 是一个定值。比如正中间对角线（主对角线）的 i−j 恒为 0                      
设 k=i−j+n，那么右上角那条对角线的 k=0−(n−1)+n=1，左下角那条对角线的 k=(m−1)−0+n=m+n−1。*                          

**枚举 k=1,2,3,…,m+n−1，就相当于在从右上到左下，一条一条地枚举对角线。**

由于 i−j+n=k，知道 j 就知道 i，所以我们只需要计算出每条对角线的 j 的最小值和最大值，就可以开始遍历对角线了。            
- 由于 j=i−k+n，当 i=0 时 j 取到最小值 n−k，但这个数不能是负数，所以最小的 j 是 max(n−k,0)。                        
- 由于 j=i−k+n，当 i=m−1 时 j 取到最大值 m+n−1−k，但这个数不能超过 n−1，所以最大的 j 是 min(m+n−1−k,n−1)。                  


[3446. 按对角线进行矩阵排序 1373](https://leetcode.cn/problems/sort-matrix-by-diagonals/)*（未完成）*

## summary
在枚举（遍历）的过程中用**某种数据结构**保存其他还未被枚举的元素，从而实现能在枚举当前元素时就能进行判断并更新result

## 一、前缀和

### note（基础）
