## 零、常用枚举技巧

### note（枚举右，维护左）
对于双变量问题，例如两数之和ai​+aj​=t，可以**枚举右边的aj​，转换成单变量问题**，也就是**在aj​左边查找是否有ai​=t−aj**，这可以**用哈希表维护**。

### note（枚举中间）
三变量i, j, k 枚举中间的 nums[j]                         
定义 **suf[k]（可以为list,map,set...）表示从 nums[k] 到 nums[size−1] 的值（后缀）**，              
定义 **pre[i]（可以为list,map,set...）表示从 nums[0] 到 nums[i] 的值（前缀）**                      
前缀可以和答案一起算。

[2909. 元素和最小的山形三元组 II 1479](https://leetcode.cn/problems/minimum-sum-of-mountain-triplets-ii/)*（未完成）*

### note（遍历对角线）
#### 方法1
*对于每条对角线，行号 i 减列号 j 是一个定值。比如正中间对角线（主对角线）的 i−j 恒为 0                      
设 **k=i−j+n**，那么右上角那条对角线的 k=0−(n−1)+n=1，左下角那条对角线的 k=(m−1)−0+n=m+n−1。*                          

**枚举 k=1,2,3,…,m+n−1，就相当于在从右上到左下，一条一条地枚举对角线。**

由于 i−j+n=k，知道 j 就知道 i，所以我们只需要计算出每条对角线的 j 的最小值和最大值，就可以开始遍历对角线了。            
- 由于 j=i−k+n，当 i=0 时 j 取到最小值 n−k，但这个数不能是负数，所以最小的 j 是 max(n−k,0)。                        
- 由于 j=i−k+n，当 i=m−1 时 j 取到最大值 m+n−1−k，但这个数不能超过 n−1，所以最大的 j 是 min(m+n−1−k,n−1)。                  

#### 方法2
写一个 diagonal() 函数，从**对角线头**向**对角线尾**遍历（枚举）                   
遍历中更新 行i++ 和 列j++                        
然后直接调用 diagonal() 函数：
```cpp
// 1. 遍历第一行的所有起点
for (int c = 0; c < n; c++) {
    diagonal(0, c);
}

// 2. 遍历第一列的所有起点 (跳过 0,0，因为上面已经处理过了)
for (int r = 1; r < m; r++) {
    diagonal(r, 0);
}
```
[3446. 按对角线进行矩阵排序 1373](https://leetcode.cn/problems/sort-matrix-by-diagonals/)*（未完成）*

## summary
***枚举（遍历）技巧：for循环遍历每个元素，以下顺序为模版：right维护数据--，进行当前判断，left维护数据++。***                     
在枚举（遍历）的过程中用**某种数据结构**保存其他还未被枚举的元素，从而实现能在枚举当前元素时就能进行判断并更新result.              

## 一、前缀和

### note（基础）
对于数组 a，计算它的长为 n+1 的前缀和数组 s，即 a 的前 0 个数的和，前 1 个数的和，前 2 个数的和……前 n 个数的和。
```cpp
s[0]=0             
s[1]=a[0]                 
s[2]=a[0]+a[1]                
  ⋮
s[i]=a[0]+a[1]+⋯+a[i−1]                        
s[i+1]=a[0]+a[1]+⋯+a[i−1]+a[i]                
  ⋮
s[n]=a[0]+a[1]+⋯+a[n−1]
```
​​
根据这个定义，前 i 个数的和，加上 a[i]，就是前 i+1 个数的和，即s[i+1]=s[i]+a[i]，示例中的数组 [−2,0,3,−5,2,−1]，对应的前缀和数组 s=[0,−2,−2,1,−4,−2,−3]。                           
通过前缀和，我们可以把子数组的元素和转化成两个前缀和的差，下标区间 [left,right] 的元素和等于前缀 [0,right] 的元素和减去另一个前缀 [0,left−1] 的元素和，即***s[right+1]−s[left]***，有了这个式子，示例中子数组 [3,−5,2,−1] 的和，就可以 O(1) 地用 s[6]−s[2]=−3−(−2)=−1 算出来。

[303. 区域和检索 - 数组不可变](https://leetcode.cn/problems/range-sum-query-immutable/)

### note（前缀和与哈希表）
这里的遍历技巧可以参考summary中的遍历技巧
