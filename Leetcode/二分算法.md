## 一、二分查找

### note

|需求	|写法	|如果不存在|
|-----|-----|-----|
|≥x 的第一个元素的下标|	lowerBound(nums,x)	|结果为 n|
|>x 的第一个元素的下标|	lowerBound(nums,x+1)	|结果为 n|
|<x 的最后一个元素的下标|	lowerBound(nums,x)−1	|结果为 −1|
|≤x 的最后一个元素的下标|	lowerBound(nums,x+1)−1	|结果为 −1|
#### 开区间写法（最常用）
```cpp
// lower_bound 返回最小的满足 nums[i] >= target 的下标 i
// 如果数组为空，或者所有数都 < target，则返回 nums.size()
// 要求 nums 是非递减的，即 nums[i] <= nums[i + 1]
int lower_bound(vector<int>& nums, int target) {
    int left = -1, right = nums.size(); // 开区间 (left, right)
    while (left + 1 < right) { // 区间不为空
        // 循环不变量：
        // nums[left] < target
        // nums[right] >= target
        int mid = left + (right - left) / 2;
        if (nums[mid] >= target) {
            right = mid; // 范围缩小到 (left, mid)
        } else {
            left = mid; // 范围缩小到 (mid, right)
        }
    }
    // 循环结束后 left+1 = right
    // 此时 nums[left] < target 而 nums[right] >= target
    // 所以 right 就是第一个 >= target 的元素下标
    return right;
}
```

## 二、二分答案

### note（求最小）

### summary
在练习时，请注意「求最小」和「求最大」的二分写法上的区别。

「求最小」和二分查找求「排序数组中某元素的第一个位置」是类似的，按照红蓝染色法，左边是不满足要求的（红色），右边则是满足要求的（蓝色）。

「求最大」的题目则相反，左边是满足要求的（蓝色），右边是不满足要求的（红色）。这会导致二分写法和上面的「求最小」有一些区别。

以开区间二分为例：

求最小：check(mid) == true 时更新 right = mid，反之更新 left = mid，最后返回 right。             
求最大：check(mid) == true 时更新 left = mid，反之更新 right = mid，最后返回 left。                     
对于开区间写法，简单来说 check(mid) == true 时更新的是谁，最后就返回谁。相比其他二分写法，开区间写法不需要思考加一减一等细节，个人推荐使用开区间写二分。                     
